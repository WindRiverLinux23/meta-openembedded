From 7a1a590372e1e47acf1b3b3bf0006bdb546d58d5 Mon Sep 17 00:00:00 2001
From: Jakub Jelen <jjelen@redhat.com>
Date: Thu, 16 Nov 2023 09:55:47 +0100
Subject: [PATCH 19/19] epass2003: Avoid heap buffer overflow

Removes also needless malloc & memcpy instead of returning the first
allocated buffer.

Thanks oss-fuzz

https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64215

CVE: CVE-2023-40661
Upstream-Status: Backport [ 609164045facaeae193feb48d9c2fc5cc4321e8a ]

Signed-off-by: Changqing Li <changqing.li@windriver.com>
---
 src/libopensc/card-epass2003.c    | 30 +++++++++++++++---------------
 src/libopensc/cardctl.h           |  1 +
 src/pkcs15init/pkcs15-epass2003.c |  7 ++++---
 3 files changed, 20 insertions(+), 18 deletions(-)

diff --git a/src/libopensc/card-epass2003.c b/src/libopensc/card-epass2003.c
index d8a88fa3..bf9bf3dd 100644
--- a/src/libopensc/card-epass2003.c
+++ b/src/libopensc/card-epass2003.c
@@ -2917,11 +2917,21 @@ epass2003_gen_key(struct sc_card *card, sc_epass2003_gen_key_data * data)
 	if (len < apdu.resplen)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
 
-	if(256 == len)
+	if(256 == len) /* ECC 256 bit */
 	{
-		int xCoordinateLen = rbuf[1];
-		int yCoordinateLen = rbuf[2+xCoordinateLen+1];
-		unsigned char * tmp =(u8 *)malloc(xCoordinateLen + yCoordinateLen);
+		size_t xCoordinateLen = rbuf[1];
+		size_t yCoordinateLen;
+		unsigned char *tmp;
+
+		if (2 + xCoordinateLen + 1 >= apdu.resplen) {
+			LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);
+		}
+		yCoordinateLen = rbuf[2 + xCoordinateLen + 1];
+		if (2 + xCoordinateLen + 2 + yCoordinateLen >= apdu.resplen) {
+			LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);
+		}
+		data->modulus_len = xCoordinateLen + yCoordinateLen;
+		tmp = (u8 *)malloc(data->modulus_len);
 		if(!tmp)
 		{
 			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
@@ -2944,17 +2954,7 @@ epass2003_gen_key(struct sc_card *card, sc_epass2003_gen_key_data * data)
 			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OBJECT_NOT_VALID);
 		}
 
-		data->modulus = (u8 *) malloc(xCoordinateLen + yCoordinateLen);
-		if (!data->modulus)
-		{
-			free(tmp);
-			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
-		}
-		else
-		{
-			memcpy(data->modulus, tmp, xCoordinateLen+yCoordinateLen);
-			free(tmp);
-		}
+		data->modulus = tmp;
 	}
 	else
 	{
diff --git a/src/libopensc/cardctl.h b/src/libopensc/cardctl.h
index 2ec2852c..362f361b 100644
--- a/src/libopensc/cardctl.h
+++ b/src/libopensc/cardctl.h
@@ -831,6 +831,7 @@ typedef struct sc_epass2003_gen_key_data_st {
 	 int pukey_id;
 	 size_t key_length;
 	 u8 *modulus;
+	 int modulus_len;
 } sc_epass2003_gen_key_data;
 
 
diff --git a/src/pkcs15init/pkcs15-epass2003.c b/src/pkcs15init/pkcs15-epass2003.c
index 91d406c0..fc685e3e 100644
--- a/src/pkcs15init/pkcs15-epass2003.c
+++ b/src/pkcs15init/pkcs15-epass2003.c
@@ -638,10 +638,11 @@ static int epass2003_pkcs15_generate_key(struct sc_profile *profile,
 	gendat.pukey_id = pukf->id;
 	gendat.key_length = keybits;
 	gendat.modulus = NULL;
+	gendat.modulus_len = 0;
 	r = sc_card_ctl(card, SC_CARDCTL_ENTERSAFE_GENERATE_KEY, &gendat);
 	SC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,
 		    "generate RSA key pair failed");
-	
+
 	if (!gendat.modulus) {
 		r = SC_ERROR_OUT_OF_MEMORY;
 		goto err;
@@ -679,8 +680,8 @@ static int epass2003_pkcs15_generate_key(struct sc_profile *profile,
 		}
 
 		pubkey->u.ec.ecpointQ.value[0] = 0x04;
-		memcpy(&pubkey->u.ec.ecpointQ.value[1], gendat.modulus, 64);
-		pubkey->u.ec.ecpointQ.len = 65;
+		memcpy(&pubkey->u.ec.ecpointQ.value[1], gendat.modulus, gendat.modulus_len);
+		pubkey->u.ec.ecpointQ.len = gendat.modulus_len;
 
 		free(pubkey->u.ec.params.named_curve);
 		pubkey->u.ec.params.named_curve = NULL; 
-- 
2.25.1

